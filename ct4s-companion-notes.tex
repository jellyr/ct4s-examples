\documentclass[12pt,twocolumn,oneside]{book}

\begin{document}

\setcounter{secnumdepth}{5}

\newcommand{\see}[2]{
        See \texttt{#1}, the line starting with \texttt{#2}.
    }
\newcommand{\reference}[4]{
        #1{#2} \see{#3}{#4}
    }

\chapter*{Introduction}

The purpose of this document is to use Coq to go over the examples from
\emph{Category Theory for Scientists}, a book on Category Theory by David
Spivak at MIT that is designed to be accessible to non-mathematicians. Often it
can be easy to be lost in mathematical definitions. However, programming definitions
can often be easier: programs require a much greater degree of explicitness.

The language Coq is good for this purpose because its types correspond to those
of category theory quite effectively. Additionally, being dependently typed means
that it is not difficult to, for example, define the set of numbers less than $n$
as a type dependent on $n$.

In any case, this document is intended to be an index, taking the form of \emph{CT4S}
in terms of chapter, section, etc, starting at chapter 4, where Spivak introduces
formal category-theoretic concepts. Each section will refer to the appropriate
part of one of the Coq files.

\setcounter{chapter}{3}
\chapter{Basic Category Theory}


\section{Categories and Functors}

\subsection{Categories}

\reference{\subsubsection}{Definition of a Category}{Category.v}{Class Category}

\subsubsection{Universes and Sets}

Coq's \texttt{Type} has built-in an inferred set of Grothendiek's universes. Therefore,
while \texttt{Type : Type}, the \texttt{Type}s on each side of the colon are in fact
distinct, and the one on the left is in a smaller universe.

\subsubsection{The category \textbf{Set}}

In Coq, it is more natural to use types rather than sets as a model category, but
they are fairly similar: \see{Category.v}{Instance FunCat}. Notice that the proof
is trivial in all three cases.

However, we can in fact implement Categories for \textbf{Set}, although it ends
up being more complicated. Functional equality in \textbf{Set} requires us to prove
that all the targets and sources line up before and after, which can be a pain.\footnote{
Also, we have to prove that our proofs are equivalent, which is also a pain, but
it hopefully more easily resolved.}

\subsubsection{The category \textbf{Fin}}

We can create \textbf{Fin} by requiring sets to be finite. An implementation is
provided in \texttt{FinCategory.v}. Because the difference between \textbf{Set}
and \textbf{Fin} is entirely a result of a restriction on the objects, the proofs
here are almost entirely structural, we just unfold all the \textbf{Fin}--specific
stuff and then apply the \textbf{Set} laws.

\subsubsection{The category \textbf{Mon}}

An implementation of Monoids, along with monoid homomorphism, is presented in
\texttt{Monoid.v}. The implementation of Monoids as categories is accomplished
in \texttt{MonCat.v}. Notice how almost all the actual, non-structural proving
that occurs in \texttt{MonCat.v} is in defining the composition of monoid
homomorphism, not in the actual implementation of monoids as a category. This is
because monoid homomorphism being a category follows directly from functions being
a category, since they are in essence just functions between monids, but the fact
that their compositions are homomorphism requires some thought.

\subsubsection{The category \textbf{Grp}}

This ends up being a fairly simple extension of \textbf{Mon} because there is only
one additional operation, negation, and two additional laws, the left and right
cancellation laws. As the theorem \texttt{group\_hom\_preserves\_inv} demonstrates,
the additional group homomorphism law derives entirely from the monoid laws and
cancellation laws. Therefore, the implementation of groups as categories is in
fact completely structural, simply requiring the unpacking of the various wrappers
and the application of the Monoid laws.

\subsubsection{The category \textbf{PrO}}

This ends up being a simpler repeat of \textbf{Mon}. Almost all the work is in
proving that the composition of two preorder homomorphisms is a preorder
homomorphism, with the statement about compositions being a trivial conclusion of
the fact that preorder homomorphisms are functions.

\subsubsection{Graph Category}

Implementing a noncategory is difficult and probably not of much interest, but
we can implement the category produced by the end of the section.

\end{document}