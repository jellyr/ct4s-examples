\documentclass[12pt,twocolumn,oneside]{book}

\begin{document}

\setcounter{secnumdepth}{5}

\newcommand{\see}[2]{
        See \texttt{#1}, the line starting with \texttt{#2}.
    }
\newcommand{\reference}[4]{
        #1{#2} \see{#3}{#4}
    }

\chapter*{Introduction}

The purpose of this document is to use Coq to go over the examples from
\emph{Category Theory for Scientists}, a book on Category Theory by David
Spivak at MIT that is designed to be accessible to non-mathematicians. Often it
can be easy to be lost in mathematical definitions. However, programming definitions
can often be easier: programs require a much greater degree of explicitness.

The language Coq is good for this purpose because its types correspond to those
of category theory quite effectively. Additionally, being dependently typed means
that it is not difficult to, for example, define the set of numbers less than $n$
as a type dependent on $n$.

In any case, this document is intended to be an index, taking the form of \emph{CT4S}
in terms of chapter, section, etc, starting at chapter 4, where Spivak introduces
formal category-theoretic concepts. Each section will refer to the appropriate
part of one of the Coq files.

\setcounter{chapter}{3}
\chapter{Basic Category Theory}


\section{Categories and Functors}

\subsection{Categories}

\reference{\subsubsection}{Definition of a Category}{Category.v}{Class Category}

\subsubsection{Universes and Sets}

Coq's \texttt{Type} has built-in an inferred set of Grothendiek's universes. Therefore,
while \texttt{Type : Type}, the \texttt{Type}s on each side of the colon are in fact
distinct, and the one on the left is in a smaller universe.

\subsubsection{The category \textbf{Set}}

In Coq, it is more natural to use types rather than sets as a model category, but
they are fairly similar: \see{Category.v}{Instance CoqCat}. Notice that the proof
is trivial in all three cases.

However, we can in fact implement Categories for \textbf{Set}, although it ends
up being more complicated. Functional equality in \textbf{Set} requires us to prove
that all the targets and sources line up before and after, which can be a pain.\footnote{
Also, we have to prove that our proofs are equivalent, which is also a pain, but
it hopefully more easily resolved.}

\subsubsection{The category \textbf{Fin}}

We can create \textbf{Fin} by requiring sets to be finite. An implementation is
provided in \texttt{FinCategory.v}. Because the difference between \textbf{Set}
and \textbf{Fin} is entirely a result of a restriction on the objects, we can implement
this in terms of a Full subcategory, which we define in \texttt{FullSubcat.v}.

\subsubsection{The category \textbf{Mon}}

An implementation of Monoids, along with monoid homomorphism, is presented in
\texttt{Monoid.v}. The implementation of Monoids as categories is accomplished
in \texttt{MonCat.v}. Notice how almost all the actual, non-structural proving
that occurs in \texttt{MonCat.v} is in defining the composition of monoid
homomorphism, not in the actual implementation of monoids as a category. This is
because monoid homomorphism being a category follows directly from functions being
a category, since they are in essence just functions between monids, but the fact
that their compositions are homomorphism requires some thought.

\subsubsection{The category \textbf{Grp}}

This ends up being a fairly simple extension of \textbf{Mon} because there is only
one additional operation, negation, and two additional laws, the left and right
cancellation laws. As the theorem \texttt{group\_hom\_preserves\_inv} demonstrates,
the additional group homomorphism law derives entirely from the monoid laws and
cancellation laws. Therefore, the implementation of groups as categories is in
fact completely structural, simply requiring the unpacking of the various wrappers
and the application of the Monoid laws.

\subsubsection{The category \textbf{PrO}}

This ends up being a simpler repeat of \textbf{Mon}. Almost all the work is in
proving that the composition of two preorder homomorphisms is a preorder
homomorphism, with the statement about compositions being a trivial conclusion of
the fact that preorder homomorphisms are functions.

\subsubsection{A finite category}

Finite categories are a complete pain to implement, so I forgoed this one. However,
I believe that they should be theoretically possible.

\subsubsection{The unit category where morphisms are natural numbers}

An implementation is provided in \texttt{UnitNatMorph.v}. It is a fairly simple
proof that relies on formal similarities between function composition and multiplication.

\subsubsection{Preorders with Joins}

An implementation of Preorders with joins is provided in \texttt{PreorderJoin.v}.
The categorical instance \textbf{PrOJ} is also provided. Similarly to \textbf{PrO}
and \textbf{Mon}, most of the real non-entirely-structural work is in proving that
compositions work.

\subsubsection{Linear Orders}

Technically, I should have been doing all these in \textbf{Set}, but I've been
doing them in \textbf{Coq} this whole time (i.e., the category of Coq
types and functions), so it's rather difficult to define finite sets.

However, defining \textbf{Lin} isn't that bad. I implemented the concept of full
subcategories in \texttt{FullSubcat.v} and implemented \textbf{Lin} in those terms
in \texttt{LinearOrder.v}
\stepcounter{subsubsection}

\subsubsection{The category \textbf{Grph}}

An implementation of graphs as defined in 3.3.1 of \emph{CT4S} is provided in
\texttt{Graph.v}. An implementation of graphs as categories is provided in
\texttt{GraphCat.v}. Again, most of the work was in being able to compose homorphisms
to get new homorphisms.
\stepcounter{subsubsection}
\stepcounter{subsubsection}

\subsubsection{Isomoprhisms}

A definition of isomorphism is given in \texttt{Isomorphism.v}.

\subsubsection{Isomorphisms in \textbf{Set}}

The definition given in \texttt{Isomorphism.v} is general enough for any category.

\stepcounter{subsubsection}
\subsubsection{Isomorphisms in \textbf{Grph} imply isomorphisms in \textbf{Set}}

A proof of this fact is given as \texttt{grph\_iso\_impl\_srctgt\_iso} in \texttt{IsomorphismSetGrph.v}.
Note how the necessary proofs just need to be extracted from the graph proof.

\subsubsection{Isomorphisms in \textbf{Set} imply isomorphisms in \textbf{Grph}}

A proof of this fact is given in \texttt{IsomorphismSetGrph.v}. The major portion of the
proof is that the function on graphs given by the inverse of each of the components
of a homorphism is in fact a homorphism. This should probably be a shorter proof,
I need a better way of encoding diagram chase.

\subsubsection{Isomorphisms as an equivalence relation}

A definition of equivalence is given in \texttt{Equivalence.v}. An implementation
of isomorphism as equivalence is given in \texttt{IsoEquiv.v}. Note that the proof
is fairly simple, relying on a few fairly simple diagtram chases.

\subsubsection{A data structure for categories}

The description in \emph{CT4S} in this section is basically describing the encoding
of categories as data structures. This definition is given in \texttt{Category.v}.

\subsection{Functors}

\subsubsection{Definition of Functors}

A definition of functors is given in \texttt{Functor.v}.

\subsubsection{$\mathbf{Mon} \to \mathbf{Coq}$}

Instead of a function from monoids to sets, we can map monoids to their underlying types, because
of our usage of \textbf{Coq} rather than \textbf{Set}. An implementation is provided
in \texttt{Forgetful.v}, and the corresponding \textbf{Cat} objects are provided in \texttt{Monoid.v}
and \texttt{Category.v}. Note how the entire proof is in unfolding a few definitions and
asserting reflexivity.

\subsubsection{$\mathbf{Grp} \to \mathbf{Mon}$}

A similar transformation can be defined. We again just need to unwrap all the Group
definitions everything reduces to reflexive relations. An implementation is provided
in \texttt{Forgetful.v}.

\stepcounter{subsubsection}\stepcounter{subsubsection}

\subsubsection{$\mathbf{Set} \to \mathbf{Fin}$}

Again, a forgetful functor, defined in \texttt{Forgetful.v}, can be defined for all full
subcategories and then specialized to Set and Fin.

\subsubsection{$\mathbf{Lin} \to \mathbf{PrO}$}

A forgetful functor, defined in \texttt{Forgetful.v} is implemented as another
implementation of the general forgetful functor from a full subcategory to its
containing category.

\subsubsection{$\mathbf{Pro} \to \mathbf{Grph}$}

This is the first nontrivial functor being implemented, however the proofs are
still relatively structural. The example is given in \texttt{ProGrphFun.v}.



\end{document}